package golang

import (
	"go/types"
	"strings"

	"github.com/pkg/errors"
	"github.com/webrpc/webrpc/schema"
)

func (p *parser) parseType(typ types.Type) (varType *schema.VarType, err error) {
	return p.parseNamedType("", typ)
}

func (p *parser) parseNamedType(typeName string, typ types.Type) (varType *schema.VarType, err error) {
	if cached, ok := p.parsedTypes[typ]; ok {
		return cached, nil
	}

	// We want to parse each type just once. So we store the result in cache. But also, we need
	// to lock the cache for recursive types to prevent endless recursion for linked lists etc.
	// Note: We're parsing sequentially, no need for sync.Map.
	lockRecursiveTypes := &schema.VarType{}
	p.parsedTypes[typ] = lockRecursiveTypes
	defer func() {
		if err != nil {
			delete(p.parsedTypes, typ)
			return
		}

		// Update the value in cache for any following calls once we're done.
		*lockRecursiveTypes = *varType
	}()

	switch v := typ.(type) {
	case *types.Named:
		typeName := v.Obj().Name()
		pkg := v.Obj().Pkg()
		if pkg != nil {
			// If the type belongs to a specific package, save the pkg reference to schema.Imports.
			// Prefix the type name with the package name to avoid conflicts.
			pkgPath := pkg.Path()

			// "command-line-arguments" is autogenerated by Go tool chain. Ignore.
			if pkgPath == "command-line-arguments" || pkgPath == p.schemaPkgName {
				pkgPath = ""
			}

			switch pkgPath + "." + typeName {
			case "time.Time":
				var varType schema.VarType
				if err := schema.ParseVarTypeExpr(p.schema, "timestamp", &varType); err != nil {
					return nil, errors.Wrap(err, "failed to parse timestamp")
				}
				return &varType, nil
			}

			typeName = pkgPath + strings.ToUpper(typeName[0:1]) + typeName[1:]

			if _, ok := p.resolvedImports[pkgPath]; !ok {
				p.resolvedImports[pkgPath] = struct{}{}
				p.schema.Imports = append(p.schema.Imports, &schema.Import{
					Path: pkgPath,
				})
			}
		}
		return p.parseNamedType(typeName, v.Underlying())

	case *types.Basic:
		return p.parseBasic(v)

	case *types.Struct:
		return p.parseStruct(typeName, v)

	case *types.Slice:
		return p.parseSlice(typeName, v)

	case *types.Interface:
		return p.parseInterface(typeName, v)

	case *types.Map:
		return p.parseMap(typeName, v)

	case *types.Pointer:
		// TODO: Consider adding schema.T_Pointer, or add metadata to Golang
		// type to distinguish between "pointer to struct" vs. "plain struct".
		varType, err = p.parseNamedType(typeName, v.Elem())
		if err != nil {
			return nil, errors.Wrap(err, "failed to dereference pointer")
		}
		return varType, nil

	default:
		return nil, errors.Errorf("unsupported argument type %T", typ)
	}
}

func (p *parser) parseBasic(typ *types.Basic) (*schema.VarType, error) {
	var varType schema.VarType
	if err := schema.ParseVarTypeExpr(p.schema, typ.Name(), &varType); err != nil {
		return nil, errors.Wrapf(err, "failed to parse basic type: %v", typ.Name())
	}

	return &varType, nil
}

func (p *parser) parseStruct(typeName string, structTyp *types.Struct) (*schema.VarType, error) {
	// typeName is for example "github.com/webrpc/webrpc/schema/VarType"
	// Split by separators & get the shortest possible unique prefixed type name (ie. schemaVarType).
	typeNameParts := strings.FieldsFunc(typeName, func(r rune) bool {
		return r == '.' || r == '/' || r == '-' || r == '_'
	})
	typeName = ""
	for i := len(typeNameParts) - 1; i >= 0; i-- {
		typeName = typeNameParts[i] + typeName
		if _, ok := p.parsedTypeNames[typeName]; !ok {
			p.parsedTypeNames[typeName] = struct{}{}
			break
		}
	}

	msg := &schema.Message{
		Name: schema.VarName(typeName),
		Type: schema.MessageType("struct"),
	}

	for i := 0; i < structTyp.NumFields(); i++ {
		field := structTyp.Field(i)
		if !field.Exported() {
			continue
		}

		tag := structTyp.Tag(i)
		if field.Embedded() || strings.Contains(tag, `json:",inline"`) {
			varType, err := p.parseNamedType("", field.Type())
			if err != nil {
				return nil, errors.Wrapf(err, "failed to parse var %v", field.Name())
			}

			if varType.Type == schema.T_Struct {
				for _, embeddedField := range varType.Struct.Message.Fields {
					msg.Fields = appendMessageFieldAndDeleteExisting(msg.Fields, embeddedField)
				}
			}
			continue
		}

		fieldName := field.Name()

		// We need to provide a type name for anonymous structs. {currentStructType}{FieldName}
		var anonymousStructTypeName string
		if _, ok := field.Type().Underlying().(*types.Struct); ok {
			anonymousStructTypeName = typeName + strings.ToTitle(fieldName[:1]) + fieldName[1:]
		}

		varType, err := p.parseNamedType(anonymousStructTypeName, field.Type())
		if err != nil {
			return nil, errors.Wrapf(err, "failed to parse var %v", field.Name())
		}

		msg.Fields = appendMessageFieldAndDeleteExisting(msg.Fields, &schema.MessageField{
			Name: schema.VarName(fieldName),
			Type: varType,
		})
	}

	varType := &schema.VarType{
		Type: schema.T_Struct,
		Struct: &schema.VarStructType{
			Name:    typeName,
			Message: msg,
		},
	}

	p.schema.Messages = append(p.schema.Messages, msg)

	return varType, nil
}

// Appends message field to the given slice, while also removing any previously defined field of the same name.
// This lets us overwrite embedded fields, exactly how Go does it behind the scenes in the JSON marshaller.
func appendMessageFieldAndDeleteExisting(slice []*schema.MessageField, newItem *schema.MessageField) []*schema.MessageField {
	// Let's try to find an existing item of the same name and delete it.
	for i, item := range slice {
		if item.Name == newItem.Name {
			// Delete item.
			copy(slice[i:], slice[i+1:])
			slice = slice[:len(slice)-1]
		}
	}
	// And then append the new item at the end of the slice.
	return append(slice, newItem)
}

func (p *parser) parseSlice(typeName string, sliceTyp *types.Slice) (*schema.VarType, error) {
	elem, err := p.parseNamedType(typeName, sliceTyp.Elem())
	if err != nil {
		return nil, errors.Wrap(err, "failed to parse slice type")
	}

	varType := &schema.VarType{
		Type: schema.T_List,
		List: &schema.VarListType{
			Elem: elem,
		},
	}

	return varType, nil
}

// Parse argument of type interface. We only allow context.Context and error.
func (p *parser) parseInterface(typeName string, iface *types.Interface) (*schema.VarType, error) {
	// TODO: A special case for error and context.Context.

	varType := &schema.VarType{
		Type: schema.T_Any,
	}

	return varType, nil
}

// Parse argument of type interface. We only allow context.Context and error.
func (p *parser) parseMap(typeName string, m *types.Map) (*schema.VarType, error) {
	key, err := p.parseNamedType(typeName, m.Key())
	if err != nil {
		return nil, errors.Wrap(err, "failed to parse map key type")
	}

	value, err := p.parseNamedType(typeName, m.Elem())
	if err != nil {
		return nil, errors.Wrap(err, "failed to parse map value type")
	}

	varType := &schema.VarType{
		Type: schema.T_Map,
		Map: &schema.VarMapType{
			Key:   key.Type,
			Value: value,
		},
	}

	return varType, nil
}
